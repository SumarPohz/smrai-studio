<%- include("partials/header") %>

<%
  // Normalize template name
  const tpl = template || "modern-1";

  // Allowed template IDs for partial loading
  const validTemplates = [
    "modern-1", "bold-sidebar", "minimal-1", "creative-gradient",
    "corporate-clean", "elegant-serif", "tech-focused", "classic-border",
    "ats-friendly",
    "ats-customer-service", "ats-sales", "ats-marketing", "ats-healthcare",
    "ats-finance", "ats-teacher", "ats-hr", "ats-engineering",
    "ats-admin", "ats-legal", "ats-logistics", "ats-hospitality"
  ];
  const safeTpl = validTemplates.includes(tpl) ? tpl : "modern-1";

  // Parse experience into [{title, company, dates, description}] objects.
  // Accepts either:
  //   â€¢ Array of objects (from AI Interview / JSONB storage)
  //   â€¢ Plain text string (legacy textarea format)
  function parseExperience(input) {
    // --- Array format (from AI Interview) ---
    if (Array.isArray(input)) {
      return input
        .filter(item => item && typeof item === "object")
        .map(item => ({
          title: item.title || "",
          company: item.company || "",
          dates: item.dates || "",
          // Split on any newline variant, trim each line, remove blank-only lines
          description: (item.description || "")
            .split(/\r?\n/)
            .map(l => l.trim())
            .filter(l => l.length > 0)
            .join("\n")
        }));
    }

    // --- String format (legacy) ---
    if (!input || typeof input !== "string") return [];

    const lines = input
      .split(/\r?\n+/)
      .map(l => l.trim())
      .filter(l => l.length > 0);

    const jobs = [];
    let currentHeading = null;
    let currentDesc = [];

    for (const line of lines) {
      if (/^-/.test(line)) {
        if (currentHeading) {
          jobs.push({ heading: currentHeading, description: currentDesc.join(" ") });
        }
        currentHeading = line.replace(/^-\s*/, "");
        currentDesc = [];
      } else {
        currentDesc.push(line);
      }
    }

    if (currentHeading) {
      jobs.push({ heading: currentHeading, description: currentDesc.join(" ") });
    }

    return jobs.map(job => {
      // "Title [Company] (dates)" OR "Title (dates)"
      const mFull = job.heading.match(/^(.*?)\s*\[([^\]]+)\]\s*(\(.*\))\s*$/);
      const mDates = job.heading.match(/^(.*?)(\(\s*\d{4}.*\))\s*$/);
      if (mFull) {
        return { title: mFull[1].trim(), company: mFull[2].trim(), dates: mFull[3].trim(), description: job.description };
      }
      if (mDates) {
        return { title: mDates[1].trim(), company: "", dates: mDates[2].trim(), description: job.description };
      }
      return { title: job.heading, company: "", dates: "", description: job.description };
    });
  }

  // Simple bullets for skills: 1 line = 1 pill
  function renderBullets(text) {
    if (!text || typeof text !== "string") return [];
    return text
      .split(/\r?\n+/)
      .map(line => line.replace(/^\s*[-*â€¢]\s*/, ""))
      .map(line => line.trim())
      .filter(line => line.length > 0);
  }

  let _expInput = data.experience || "";
  if (data.experienceJson) {
    try { _expInput = JSON.parse(data.experienceJson); } catch (_) {}
  }
  const experienceItems = parseExperience(_expInput);
  const skillsLines = renderBullets(data.skills || "");

  // Parse "Category: skill1, skill2" lines â†’ [{category, skills:[]}]
  function parseTechnologies(text) {
    if (!text || typeof text !== "string") return [];
    return text.split(/\r?\n+/).map(l => l.trim()).filter(Boolean).map(line => {
      const ci = line.indexOf(":");
      if (ci === -1) return { category: "", skills: line.split(",").map(s => s.trim()).filter(Boolean) };
      return {
        category: line.slice(0, ci).trim(),
        skills: line.slice(ci + 1).split(",").map(s => s.trim()).filter(Boolean),
      };
    });
  }

  // Parse projects textarea â†’ [{name, tech, link, description:[]}]
  function parseProjects(text) {
    if (!text || typeof text !== "string") return [];
    const projects = [];
    let current = null;
    for (const raw of text.split(/\r?\n/)) {
      const line = raw.trim();
      if (!line) { if (current) { projects.push(current); current = null; } continue; }
      const pipes = (line.match(/\|/g) || []).length;
      if (pipes >= 1 && !line.startsWith("â€¢") && !line.startsWith("-")) {
        if (current) projects.push(current);
        const parts = line.split("|").map(p => p.trim());
        const name = parts[0] || "";
        let tech = "", link = "";
        for (let i = 1; i < parts.length; i++) {
          if (/^tech:/i.test(parts[i])) tech = parts[i].replace(/^tech:\s*/i, "");
          else if (/^https?:\/\//i.test(parts[i]) || parts[i].includes(".")) link = parts[i];
        }
        current = { name, tech, link, description: [] };
      } else if (current) {
        current.description.push(line);
      }
    }
    if (current) projects.push(current);
    return projects;
  }

  const technologiesCategories = parseTechnologies(data.technologies || "");
  const projectItems = parseProjects(data.projects || "");
%>

<style>
  /* ==== Preview / A4 wrapper ==== */
  .preview-section {
    padding: 1.5rem 1rem 2.5rem;
  }

  .preview-section > h1 {
    margin-bottom: 0.25rem;
  }

  .preview-section > p {
    margin-top: 0.2rem;
    margin-bottom: 0.75rem;
  }

  /* Scope UI styles to preview-section ONLY â€” not into the resume */
  .preview-section > button,
  .preview-section > .btn-primary,
  #download-image-btn,
  #download-pdf-btn {
    background: #111827;
    color: #fff;
    border: none;
    padding: 0.6rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
  }

  .preview-section > button:hover,
  .preview-section > .btn-primary:hover,
  #download-image-btn:hover,
  #download-pdf-btn:hover {
    background: #facc15;
    color: #111827;
  }

  /* Row wrapper for the two download buttons */
  .download-btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    margin-top: 1rem;
  }

  .preview-section > p > a,
  .preview-section > p a {
    color: #2563eb;
  }

  /* ===== OUTER WRAPPER: clips horizontal overflow, sized by JS ===== */
  .preview-wrapper {
    width: 100%;
    max-width: 820px;
    margin: 1rem auto;
    /*
     * overflow-x: clip  â€” prevents the 794px scale-container from creating a
     *   horizontal scrollbar on narrow screens. Unlike overflow:hidden, `clip`
     *   does NOT create a scroll container, so overflow-y can remain visible.
     * overflow-y: visible â€” content taller than the JS-set height can flow
     *   naturally; the page itself scrolls, not the wrapper.
     */
    overflow-x: clip;
    overflow-y: visible;
    position: relative;        /* stacking context for z-index */
  }

  /* ===== SCALE CONTAINER: holds the A4 and gets transform applied ===== */
  .preview-scale-container {
    width: 794px;              /* always A4 width */
    transform-origin: top left; /* set in CSS so JS never races to set it.
                                   Desktop: translateX centers it (origin irrelevant for translate).
                                   Mobile:  scale() anchors top-left â€” no rightward shift. */
  }

  /* ===== A4 CARD: captured as JPG, natural height for multi-page content ===== */
  .resume-a4 {
    width: 794px;
    min-height: 1123px;        /* A4 page height â€” content grows beyond this */
    height: auto;              /* MUST be auto so tall resumes expand naturally */
    background: #ffffff;
    box-shadow: 0 18px 40px rgba(15,23,42,0.18);
    border-radius: 8px;
    border: 1px solid #e5e7eb;
    overflow: hidden;          /* clip sidebar bg colours to border-radius */
    position: relative;
    box-sizing: border-box;
  }

  /*
   * ===== .preview-wrapper .resume-page â€” minimal safety guard =====
   * The real neutralisation of style.css legacy rules (display:flex,
   * overflow:hidden, background:#f3f4f6, margin, max-width, box-shadow,
   * border-radius) is now done in templates.css base .resume-page {} at 0,1,0
   * via cascade order (templates.css loads after style.css).
   *
   * Template-specific display/background rules at 0,2,0 in templates.css
   * are NOT overridden here, so two-column templates (modern-1, bold-sidebar)
   * get their display:flex back and tech-focused gets its dark background back.
   *
   * This rule (0,2,0) only guards the three properties most critical to
   * the preview layout being correct.
   */
  .preview-wrapper .resume-page {
    margin: 0 !important;         /* style.css: margin:1.5rem auto â€” must never apply here */
    max-width: none !important;   /* style.css: max-width:900px â€” A4 is fixed at 794px */
    overflow: visible !important; /* must never clip multi-page vertical content */
  }

  /* ===== PRINT ===== */
  @media print {
    @page {
      size: A4;
      margin: 0;
    }

    body {
      margin: 0;
      background: #ffffff;
    }

    .preview-section > h1,
    .preview-section > p,
    #download-image-btn,
    #print-btn {
      display: none !important;
    }

    .preview-wrapper {
      overflow: visible;
      max-width: none;
      height: auto !important;   /* override JS-set pixel height */
    }

    .preview-scale-container {
      transform: none !important;  /* remove translateX / scale for print */
      margin: 0 auto;
    }

    .resume-a4 {
      width: 210mm;
      border: none;
      box-shadow: none;
      border-radius: 0;
      overflow: visible;         /* let content flow across print pages */
      min-height: auto;
      height: auto;
      margin: 0 auto;
    }

    /* â”€â”€ Keep A4 page structure intact â”€â”€ */
    .resume-page {
      overflow: visible !important;
      height: auto !important;
      min-height: auto !important;
    }

    /* â”€â”€ Prevent experience entries from splitting across print pages â”€â”€ */
    .experience-list li,
    .es-exp-item,
    .tf-exp-item,
    .tf-project-card,
    .tf-cert-list li,
    .tf-achievement-list li,
    .cb-exp-item {
      page-break-inside: avoid;
      break-inside: avoid;
    }

    /* â”€â”€ Keep section headings with their first line of content â”€â”€ */
    .modern-section-block h3,
    .bs-content-section h3,
    .min-section h3,
    .cg-section h3,
    .corp-section h3,
    .es-section h3,
    .tf-left-section h2,
    .tf-right-section h2,
    .cb-section h3 {
      page-break-after: avoid;
      break-after: avoid;
    }

    /* â”€â”€ Avoid splitting whole short sections â”€â”€ */
    .modern-section-block,
    .bs-content-section,
    .min-section,
    .cg-section,
    .corp-section,
    .es-section,
    .tf-left-section,
    .cb-section {
      page-break-inside: avoid;
      break-inside: avoid;
    }
  }

  /* â”€â”€ Watermark shell â”€â”€ */
  .resume-watermark {
    position: absolute;
    inset: 0;
    z-index: 999;
    pointer-events: none;
    user-select: none;
    overflow: hidden;
  }

  /* â”€â”€ Tiled corner/edge stamps â”€â”€ */
  .wm-tile {
    position: absolute;
    display: flex;
    align-items: center;
    gap: 6px;
    transform: rotate(-30deg);
    opacity: 0.12;
    white-space: nowrap;
    font-size: 1.05rem;
    font-weight: 700;
    color: #111827;
    letter-spacing: 0.08em;
    font-family: sans-serif;
  }

  .wm-tile-logo {
    width: 26px;
    height: 26px;
    object-fit: contain;
    opacity: 1;
  }

  /* â”€â”€ Central prominent stamp â”€â”€ */
  .wm-center-stamp {
    position: absolute;
    /* top / left are set via inline style by refreshWatermark() */
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    opacity: 0.13;
  }

  .wm-center-logo {
    width: 220px;
    height: 220px;
    object-fit: contain;
  }

  .wm-center-brand {
    font-size: 4rem;
    font-weight: 800;
    color: #111827;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    font-family: sans-serif;
    line-height: 1;
  }

  .wm-center-label {
    font-size: 1.05rem;
    font-weight: 600;
    color: #111827;
    letter-spacing: 0.22em;
    text-transform: uppercase;
    font-family: sans-serif;
  }

  /* ===== MULTI-PAGE: visual page-break dividers ===== */
  .pg-break {
    position: absolute;
    left: 0;
    right: 0;
    pointer-events: none;
    z-index: 60;
    /* 16px band: top 8px = shadow of page above, bottom 8px = shadow of page below */
    height: 16px;
    background:
      linear-gradient(to bottom, rgba(0,0,0,0.12) 0%, transparent 100%);
  }

  .pg-break::before {
    content: "";
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 3px;
    background: #b0b8c9;
  }

  /* Stack multiple page cards with a visible gap */
  .preview-scale-container {
    display: flex;
    flex-direction: column;
    gap: 0;          /* pages are continuous â€” breaks shown as overlays */
  }
</style>

<section class="preview-section">
  <h1>Resume Preview</h1>
  <p>
    Review your resume below. Download as JPG or PDF after payment.
    <br />
    Template: <strong><%= tpl %></strong>
    &nbsp;&middot;&nbsp; <a href="/resume-templates">Change template</a>
  </p>

  <!-- OUTER: clips overflow, prevents horizontal scroll -->
  <div class="preview-wrapper">
    <!-- SCALE CONTAINER: JS applies transform: scale() here on mobile -->
    <div class="preview-scale-container" id="scaleContainer">
      <!-- A4 container we capture for JPG / print -->
      <div id="resumeA4" class="resume-a4">
        <!-- WATERMARK (VISIBLE UNTIL PAYMENT) â€” tiles injected per-page by refreshWatermark() -->
        <div class="resume-watermark"></div>

        <div class="resume-page <%= safeTpl %>">
          <%- include('templates/' + safeTpl, { data, experienceItems, skillsLines, qrCodeDataUrl, technologiesCategories, projectItems }) %>
        </div>
      </div>
    </div>
  </div>

  <!-- Download buttons â€” both unlock after a single payment -->
<p class="payment-note">
  ðŸ”“ One-time payment unlocks both JPG and PDF downloads.
</p>

<!-- Download buttons â€” both unlock after a single payment -->
<div class="download-btn-row">
  <button id="download-image-btn">PAY â‚¹<%= displayPrice %> &amp; DOWNLOAD JPG (A4)</button>
  <button id="download-pdf-btn">PAY â‚¹<%= displayPrice %> &amp; DOWNLOAD PDF (A4)</button>
</div>

  <p style="margin-top:1rem;">
    <a href="/resume-builder">Edit details</a>
  </p>
</section>

<!-- ===== DYNAMIC MOBILE SCALING + MULTI-PAGE BREAKS ===== -->
<script>
  (function () {
    var A4_WIDTH  = 794;
    var A4_HEIGHT = 1123;   /* px at screen resolution */

    /* Push sections that straddle a page boundary to the next page */
    function avoidPageBreaks() {
      var a4 = document.getElementById("resumeA4");
      if (!a4) return;

      /* Reset any margins we injected in a previous run */
      var prev = a4.querySelectorAll("[data-pb-push]");
      for (var i = 0; i < prev.length; i++) {
        prev[i].style.marginTop = prev[i].getAttribute("data-pb-push") || "";
        prev[i].removeAttribute("data-pb-push");
      }

      /* Sections that must not be split across pages â€” all templates */
      var nodeList = a4.querySelectorAll(
        ".modern-section-block, .exp-entry, " +
        ".bs-section, .bs-content-section, .bs-exp-item, .bs-ref-grid, .bs-ref-entry, " +
        ".min-section, " +
        ".cg-section, .cg-exp-item, .cg-refs-grid, .cg-ref-card, " +
        ".corp-section, " +
        ".es-section, " +
        ".tf-left-section, .tf-exp-item, .tf-project-card, " +
        ".cb-section"
      );

      /*
       * Sort by VISUAL top position, not DOM order.
       * Critical for two-column layouts where CSS `order` reverses DOM order
       * (e.g. ATS template: tf-right is first in DOM but visually on the right).
       * Processing top-to-bottom ensures each element's position is read AFTER
       * elements above it have already been pushed, avoiding cascade misses.
       */
      var a4Top = a4.getBoundingClientRect().top;
      var els = Array.prototype.slice.call(nodeList).sort(function (a, b) {
        return a.getBoundingClientRect().top - b.getBoundingClientRect().top;
      });

      for (var s = 0; s < els.length; s++) {
        var el = els[s];
        /* Re-read position â€” previous iterations may have pushed elements above,
           shifting this element's rendered position */
        var rect     = el.getBoundingClientRect();
        var elTop    = rect.top    - a4Top;
        var elBottom = rect.bottom - a4Top;

        var pageNum  = Math.floor(elTop / A4_HEIGHT);
        var boundary = (pageNum + 1) * A4_HEIGHT;

        /*
         * Push if:
         *  (a) element straddles the boundary (original case), OR
         *  (b) element starts within 80px of the boundary AND its bottom
         *      enters the 8px pg-break zone above the boundary â€” this
         *      prevents small sections (headings, cert lists, etc.) from
         *      touching the page-break line from above.
         */
        var straddles = elTop < boundary && elBottom > boundary;
        var nearEdge  = elTop > (boundary - 80) && elBottom > (boundary - 8);

        if (straddles || nearEdge) {
          /* Push 24px past boundary: 8px clears pg-break lower zone + 16px breathing */
          var push   = boundary - elTop + 24;
          var origMt = el.style.marginTop || "";
          el.setAttribute("data-pb-push", origMt);
          el.style.marginTop = (parseFloat(origMt) || 0) + push + "px";
        }
      }
    }

    /*
     * Inject/refresh watermark tiles â€” one set per A4 page.
     * Static HTML tiles are replaced so every page always has coverage.
     * Bails out immediately if the watermark element was removed (paid user).
     */
    function refreshWatermark() {
      var a4 = document.getElementById("resumeA4");
      var wm = a4 && a4.querySelector(".resume-watermark");
      if (!wm) return; // removed after payment

      /* Clear all existing tiles + stamps (static HTML or previous dynamic) */
      var existing = wm.querySelectorAll(".wm-tile, .wm-center-stamp");
      for (var i = 0; i < existing.length; i++) {
        existing[i].parentNode.removeChild(existing[i]);
      }

      var totalPages = Math.ceil((a4.offsetHeight || A4_HEIGHT) / A4_HEIGHT);

      for (var p = 0; p < totalPages; p++) {
        var base = p * A4_HEIGHT;

        /* Tile A â€” upper-left of this page */
        var tA = document.createElement("div");
        tA.className     = "wm-tile";
        tA.style.top     = (base + A4_HEIGHT * 0.18) + "px";
        tA.style.left    = "8%";
        tA.style.right   = "auto";
        tA.innerHTML     = '<img src="/images/logo.png" class="wm-tile-logo" alt=""><span>Not-Paid</span>';
        wm.appendChild(tA);

        /* Tile B â€” lower-right of this page */
        var tB = document.createElement("div");
        tB.className     = "wm-tile";
        tB.style.top     = (base + A4_HEIGHT * 0.65) + "px";
        tB.style.left    = "auto";
        tB.style.right   = "8%";
        tB.innerHTML     = '<img src="/images/logo.png" class="wm-tile-logo" alt=""><span>Not-Paid</span>';
        wm.appendChild(tB);

        /* Center stamp â€” middle of this page */
        var stamp        = document.createElement("div");
        stamp.className  = "wm-center-stamp";
        stamp.style.top  = (base + A4_HEIGHT * 0.45) + "px";
        stamp.style.left = "50%";
        stamp.innerHTML  =
          '<img src="/images/logo.png" class="wm-center-logo" alt="">' +
          '<span class="wm-center-brand">SmrAI-Studio</span>' +
          '<span class="wm-center-label">PREVIEW ONLY Â· NOT FOR USE</span>';
        wm.appendChild(stamp);
      }
    }

    /* Inject/refresh visual page-break dividers */
    function refreshPageBreaks() {
      var a4 = document.getElementById("resumeA4");
      if (!a4) return;

      /* Remove stale indicators */
      var old = a4.querySelectorAll(".pg-break");
      for (var i = 0; i < old.length; i++) old[i].parentNode.removeChild(old[i]);

      var totalH = a4.offsetHeight;
      var pages  = Math.ceil(totalH / A4_HEIGHT);
      if (pages <= 1) return;

      for (var p = 1; p < pages; p++) {
        var div = document.createElement("div");
        div.className = "pg-break";
        div.style.top = (p * A4_HEIGHT - 8) + "px";  /* straddle the boundary */
        a4.appendChild(div);
      }
    }

    function scalePreview() {
      var wrapper   = document.querySelector(".preview-wrapper");
      var container = document.getElementById("scaleContainer");
      var a4        = document.getElementById("resumeA4");
      if (!wrapper || !container || !a4) return;

      var availableWidth = wrapper.getBoundingClientRect().width;
      if (availableWidth > window.innerWidth) availableWidth = window.innerWidth;
      /* On mobile first-paint the wrapper may not have laid out yet â€” retry */
      if (availableWidth <= 0) { setTimeout(scalePreview, 100); return; }

      /*
       * Step 1 â€” remove any transform so avoidPageBreaks reads positions in
       * logical (un-scaled) px, which match A4_HEIGHT = 1123 exactly.
       * The browser batches DOM reads/writes in one frame so no visible flash.
       */
      container.style.transform = "none";

      /* Step 2 â€” push sections past page boundaries */
      avoidPageBreaks();

      /*
       * Step 3 â€” snap A4 height to full page multiples so every page is
       * exactly A4 height in the preview (applies to all templates).
       */
      var rawHeight  = a4.offsetHeight || A4_HEIGHT;
      var totalPages = Math.ceil(rawHeight / A4_HEIGHT);
      a4.style.minHeight  = (totalPages * A4_HEIGHT) + "px";
      var naturalHeight   = totalPages * A4_HEIGHT;

      /* Step 4 â€” apply display transform and wrapper height */
      if (availableWidth >= A4_WIDTH) {
        /* DESKTOP â€” center 794px container with translateX */
        var offset = Math.round((availableWidth - A4_WIDTH) / 2);
        container.style.transform       = "translateX(" + offset + "px)";
        container.style.transformOrigin = "top left";
        container.style.margin          = "0";
        wrapper.style.height            = naturalHeight + "px";
      } else {
        /* MOBILE â€” scale down to fit viewport width */
        var scale = availableWidth / A4_WIDTH;
        container.style.transform       = "scale(" + scale + ")";
        container.style.transformOrigin = "top left";
        container.style.margin          = "0";
        wrapper.style.height            = Math.ceil(naturalHeight * scale) + "px";
      }

      /* Step 5 â€” draw visual page-break dividers, then sync watermarks */
      refreshPageBreaks();
      refreshWatermark();
    }

    /*
     * Defer the first run by one animation frame so the browser has
     * finished painting the initial layout (getBoundingClientRect will
     * return the true rendered width, not 0 or a stale value).
     */
    function init() {
      requestAnimationFrame(function () {
        scalePreview();
      });

      /*
       * Debounce resize â€” on mobile the browser fires "resize" continuously
       * as the address-bar hides/shows during scroll; raw handler would cause
       * dozens of avoidPageBreaks() calls per second and visible jitter.
       */
      var resizeTimer;
      window.addEventListener("resize", function () {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(scalePreview, 150);
      });

      /*
       * orientationchange â€” viewport dimensions settle ~200 ms after the
       * event fires; without the delay getBoundingClientRect returns stale
       * values from the previous orientation.
       */
      window.addEventListener("orientationchange", function () {
        setTimeout(scalePreview, 250);
      });
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", init);
    } else {
      init();
    }

    /* Re-run after all resources (images, fonts) finish loading â€” the
       A4 height may increase once profile photos are rendered. */
    window.addEventListener("load", function () {
      requestAnimationFrame(scalePreview);
    });
  })();
</script>

<!-- JSZip: used to package multi-page JPG exports into a single ZIP download -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://checkout.razorpay.com/v1/checkout.js"></script>

<!-- Resume data embedded safely for PDF form submission (type=application/json prevents execution) -->
<script id="resume-payload" type="application/json">
<%- JSON.stringify({
  resumeId:        data.resumeId        || "",
  fullName:        data.fullName        || "",
  email:           data.email           || "",
  phone:           data.phone           || "",
  summary:         data.summary         || "",
  experience:      data.experience      || "",
  experienceJson:  data.experienceJson  || "",
  education:       data.education       || "",
  skills:          data.skills          || "",
  technologies:    data.technologies    || "",
  projects:        data.projects        || "",
  zipCode:         data.zipCode         || "",
  portfolioUrl:    data.portfolioUrl    || "",
  githubUrl:       data.githubUrl       || "",
  linkedinUrl:     data.linkedinUrl     || "",
  certifications:  data.certifications  || "",
  achievements:    data.achievements    || "",
  awards:          data.awards          || "",
  training:        data.training        || "",
  volunteering:    data.volunteering    || "",
  profileImageUrl: data.profileImageUrl || ""
}) %>
</script>

<script>
  (function () {
    const resumeNode = document.getElementById("resumeA4");
    const downloadBtn = document.getElementById("download-image-btn");
    const pdfBtn      = document.getElementById("download-pdf-btn");
    if (!resumeNode || !downloadBtn || !pdfBtn) return;

    const resumeId    = "<%= data.resumeId || '' %>";
    const templateName = "<%= safeTpl %>";

    // Parse the safely-embedded resume data (used for PDF form submission)
    let resumePayload = {};
    try {
      const el = document.getElementById("resume-payload");
      if (el) resumePayload = JSON.parse(el.textContent);
    } catch (_) {}

    // Shared payment flag â€” only one Razorpay transaction needed for both exports
    let paymentVerified = false;

    // ================================================================
    // Image helpers â€” convert <img> src to data URLs before capture
    // so html2canvas can read pixel data regardless of CORS headers.
    // ================================================================
    async function preloadImagesAsDataUrls(container) {
      const imgs = Array.from(container.querySelectorAll("img"));
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        if (!img.src || img.src.startsWith("data:")) continue;

        // Wait for the image to finish loading if it hasn't yet
        if (!img.complete) {
          await new Promise(function (resolve) {
            img.addEventListener("load",  resolve, { once: true });
            img.addEventListener("error", resolve, { once: true });
          });
        }

        // Fetch the image and convert to a base-64 data URL
        try {
          var res  = await fetch(img.src, { credentials: "same-origin" });
          var blob = await res.blob();
          var dataUrl = await new Promise(function (resolve) {
            var reader = new FileReader();
            reader.onload = function () { resolve(reader.result); };
            reader.readAsDataURL(blob);
          });
          img.setAttribute("data-orig-src", img.src);
          img.src = dataUrl;
        } catch (e) {
          console.warn("Could not preload image as data URL:", img.src, e);
        }
      }
    }

    function restoreImageSrcs(container) {
      container.querySelectorAll("img[data-orig-src]").forEach(function (img) {
        img.src = img.getAttribute("data-orig-src");
        img.removeAttribute("data-orig-src");
      });
    }

    // ================================================================
    // JPG generation â€” single page = direct download, multi-page = ZIP
    // ================================================================
    async function generateJpg() {
      downloadBtn.disabled = true;
      pdfBtn.disabled      = true;
      const origText = downloadBtn.textContent;
      downloadBtn.textContent = "Preparing JPGâ€¦";

      try {
        const A4_WIDTH_PX  = 2480;
        const A4_HEIGHT_PX = 3508;

        // Remove CSS transform so html2canvas sees the full unscaled element
        const scaleContainer = document.getElementById("scaleContainer");
        const prevTransform  = scaleContainer ? scaleContainer.style.transform : "";
        const wrapperEl      = document.querySelector(".preview-wrapper");
        const prevWrapperH   = wrapperEl ? wrapperEl.style.height : "";
        if (scaleContainer) scaleContainer.style.transform = "none";
        if (wrapperEl) wrapperEl.style.height = "auto";

        // Hide page-break overlays â€” must not appear in the exported images
        const pgBreaks = resumeNode.querySelectorAll(".pg-break");
        pgBreaks.forEach(function (el) { el.style.display = "none"; });

        // Convert all <img> src values to data URLs so html2canvas can
        // render them without hitting browser CORS/canvas-taint restrictions
        await preloadImagesAsDataUrls(resumeNode);

        const baseWidth = resumeNode.offsetWidth;
        const scale     = A4_WIDTH_PX / baseWidth;

        const fullCanvas = await html2canvas(resumeNode, {
          scale:           scale,
          backgroundColor: "#ffffff",
          useCORS:         true,   /* fallback for any img not converted above */
          allowTaint:      false,
          scrollX:         0,
          scrollY:         -window.scrollY,
          windowWidth:     resumeNode.scrollWidth,
          windowHeight:    resumeNode.scrollHeight,
        });

        // Restore transforms, overlays, and original image src attributes
        if (scaleContainer) scaleContainer.style.transform = prevTransform;
        if (wrapperEl) wrapperEl.style.height = prevWrapperH;
        pgBreaks.forEach(function (el) { el.style.display = ""; });
        restoreImageSrcs(resumeNode);

        const fullHeight = fullCanvas.height;
        const totalPages = Math.ceil(fullHeight / A4_HEIGHT_PX);

        // Slice canvas at page index i â†’ JPEG Blob
        function sliceToBlob(i) {
          return new Promise(function (resolve) {
            const pc    = document.createElement("canvas");
            const sliceH = Math.min(A4_HEIGHT_PX, fullHeight - i * A4_HEIGHT_PX);
            pc.width  = A4_WIDTH_PX;
            pc.height = sliceH;
            const ctx = pc.getContext("2d");
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, A4_WIDTH_PX, sliceH);
            ctx.drawImage(fullCanvas,
              0, i * A4_HEIGHT_PX, A4_WIDTH_PX, sliceH,
              0, 0,                A4_WIDTH_PX, sliceH);
            pc.toBlob(resolve, "image/jpeg", 0.95);
          });
        }

        if (totalPages === 1) {
          // â”€â”€ Single page: direct JPEG download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          const blob = await sliceToBlob(0);
          const url  = URL.createObjectURL(blob);
          const a    = document.createElement("a");
          a.download = "SmrAI-Studio-Resume.jpg";
          a.href     = url;
          a.click();
          setTimeout(function () { URL.revokeObjectURL(url); }, 5000);

        } else {
          // â”€â”€ Multiple pages: ZIP all pages then download â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          if (typeof JSZip === "undefined") {
            throw new Error("JSZip not loaded â€” cannot create ZIP file.");
          }
          downloadBtn.textContent = "Packaging " + totalPages + " pagesâ€¦";
          const zip = new JSZip();
          for (var i = 0; i < totalPages; i++) {
            const blob = await sliceToBlob(i);
            zip.file("resume-page-" + (i + 1) + ".jpg", blob);
          }
          downloadBtn.textContent = "Building ZIPâ€¦";
          const zipBlob = await zip.generateAsync({
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: { level: 6 },
          });
          const url = URL.createObjectURL(zipBlob);
          const a   = document.createElement("a");
          a.download = "SmrAI-Studio-Resume-Pages.zip";
          a.href     = url;
          a.click();
          setTimeout(function () { URL.revokeObjectURL(url); }, 10000);
        }

      } catch (err) {
        console.error("JPG export error:", err);
        alert("Failed to generate image. Check console for details.");
      } finally {
        downloadBtn.disabled    = false;
        pdfBtn.disabled         = false;
        downloadBtn.textContent = paymentVerified ? "Download JPG (A4)" : origText;
      }
    }

    // ================================================================
    // PDF generation â€” html2canvas captures the live DOM (same as JPG),
    // then jsPDF assembles pages into a downloadable PDF.
    // Layout is identical to the preview â€” no server-side rebuild needed.
    // ================================================================
    async function generatePdf() {
      pdfBtn.disabled      = true;
      downloadBtn.disabled = true;
      const origText = pdfBtn.textContent;
      pdfBtn.textContent = "Preparing PDFâ€¦";

      try {
        const A4_WIDTH_PX  = 2480;
        const A4_HEIGHT_PX = 3508;

        // Remove CSS transform so html2canvas sees the full unscaled element
        const scaleContainer = document.getElementById("scaleContainer");
        const prevTransform  = scaleContainer ? scaleContainer.style.transform : "";
        const wrapperEl      = document.querySelector(".preview-wrapper");
        const prevWrapperH   = wrapperEl ? wrapperEl.style.height : "";
        if (scaleContainer) scaleContainer.style.transform = "none";
        if (wrapperEl) wrapperEl.style.height = "auto";

        // Hide page-break overlays â€” must not appear in the exported PDF
        const pgBreaks = resumeNode.querySelectorAll(".pg-break");
        pgBreaks.forEach(function (el) { el.style.display = "none"; });

        // Convert all <img> src values to data URLs so html2canvas can
        // render them without hitting browser CORS/canvas-taint restrictions
        await preloadImagesAsDataUrls(resumeNode);

        const baseWidth = resumeNode.offsetWidth;
        const scale     = A4_WIDTH_PX / baseWidth;

        const fullCanvas = await html2canvas(resumeNode, {
          scale:           scale,
          backgroundColor: "#ffffff",
          useCORS:         true,
          allowTaint:      false,
          scrollX:         0,
          scrollY:         -window.scrollY,
          windowWidth:     resumeNode.scrollWidth,
          windowHeight:    resumeNode.scrollHeight,
        });

        // Restore transforms, overlays, and original image src attributes
        if (scaleContainer) scaleContainer.style.transform = prevTransform;
        if (wrapperEl) wrapperEl.style.height = prevWrapperH;
        pgBreaks.forEach(function (el) { el.style.display = ""; });
        restoreImageSrcs(resumeNode);

        const fullHeight = fullCanvas.height;
        const totalPages = Math.ceil(fullHeight / A4_HEIGHT_PX);

        // PDF page size in px â€” matches A4 at screen resolution
        const PDF_W = 794;
        const PDF_H = 1123;

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: "portrait",
          unit:        "px",
          format:      [PDF_W, PDF_H],
          compress:    true,
        });

        pdfBtn.textContent = totalPages > 1
          ? "Building " + totalPages + " pagesâ€¦"
          : "Building PDFâ€¦";

        for (var i = 0; i < totalPages; i++) {
          if (i > 0) pdf.addPage([PDF_W, PDF_H], "portrait");

          const sliceH = Math.min(A4_HEIGHT_PX, fullHeight - i * A4_HEIGHT_PX);

          // Slice this page from the full high-res canvas
          const pc  = document.createElement("canvas");
          pc.width  = A4_WIDTH_PX;
          pc.height = sliceH;
          const ctx = pc.getContext("2d");
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, A4_WIDTH_PX, sliceH);
          ctx.drawImage(
            fullCanvas,
            0, i * A4_HEIGHT_PX, A4_WIDTH_PX, sliceH,
            0, 0,                A4_WIDTH_PX, sliceH
          );

          const imgData  = pc.toDataURL("image/jpeg", 0.95);
          const pageImgH = (sliceH / A4_HEIGHT_PX) * PDF_H;  // proportional height for last page
          pdf.addImage(imgData, "JPEG", 0, 0, PDF_W, pageImgH);
        }

        pdf.save("SmrAI-Studio-Resume.pdf");

      } catch (err) {
        console.error("PDF export error:", err);
        alert("Failed to generate PDF. Check console for details.");
      } finally {
        pdfBtn.disabled      = false;
        downloadBtn.disabled = false;
        pdfBtn.textContent   = paymentVerified ? "Download PDF (A4)" : origText;
      }
    }

    // ================================================================
    // Razorpay payment â€” shared between JPG and PDF actions
    // Only ONE transaction is triggered; both buttons unlock after it
    // ================================================================
    async function createOrder() {
      const res  = await fetch("/api/razorpay/create-order", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ template: templateName }),
      });
      const json = await res.json();
      if (!json.success) throw new Error("Order creation failed");
      return json;
    }

    async function startPayment(action) {
      try {
        const orderData = await createOrder();

        const options = {
          key:         orderData.key,
          amount:      orderData.amount,
          currency:    orderData.currency,
          name:        "SmrAI-Studio",
          description: templateName + " Resume Download",
          order_id:    orderData.orderId,

          handler: async function (response) {
            try {
              const verifyRes = await fetch("/api/razorpay/verify", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  razorpay_order_id:   response.razorpay_order_id,
                  razorpay_payment_id: response.razorpay_payment_id,
                  razorpay_signature:  response.razorpay_signature,
                  purpose:             "download",
                  resumeId:            resumeId || null,
                }),
              });

              const verifyData = await verifyRes.json();
              if (!verifyData.success) {
                alert("Payment verification failed. Please contact support.");
                return;
              }

              // Mark payment done â€” shared state, no second charge needed
              paymentVerified = true;

              // Remove watermark
              const wm = document.querySelector(".resume-watermark");
              if (wm) wm.remove();

              // Unlock both button labels
              downloadBtn.textContent = "Download JPG (A4)";
              pdfBtn.textContent      = "Download PDF (A4)";

              // Run the action that originally triggered the payment
              if (action === "jpg") {
                await generateJpg();
              } else if (action === "pdf") {
                await generatePdf();
              }

            } catch (err) {
              console.error("Verify/payment error:", err);
              alert("Something went wrong while verifying payment.");
            }
          },

          prefill: {
            name:    resumePayload.fullName || "",
            email:   resumePayload.email    || "",
            contact: resumePayload.phone    || "",
          },
          theme: { color: "#27355a" },
        };

        new Razorpay(options).open();

      } catch (err) {
        console.error(err);
        alert("Unable to start payment. Please try again.");
      }
    }

    // ================================================================
    // Button click handlers
    // ================================================================
    downloadBtn.addEventListener("click", function () {
      if (paymentVerified) { generateJpg(); } else { startPayment("jpg"); }
    });

    pdfBtn.addEventListener("click", function () {
      if (paymentVerified) { generatePdf(); } else { startPayment("pdf"); }
    });

  })();
</script>

<%- include("partials/footer") %>

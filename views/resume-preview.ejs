<%- include("partials/header") %>

<%
  // Normalize template name
  const tpl = template || "modern-1";

  // Allowed template IDs for partial loading
  const validTemplates = [
    "modern-1", "bold-sidebar", "minimal-1", "creative-gradient",
    "corporate-clean", "elegant-serif", "tech-focused", "classic-border"
  ];
  const safeTpl = validTemplates.includes(tpl) ? tpl : "modern-1";

  // Parse experience into [{title, company, dates, description}] objects.
  // Accepts either:
  //   • Array of objects (from AI Interview / JSONB storage)
  //   • Plain text string (legacy textarea format)
  function parseExperience(input) {
    // --- Array format (from AI Interview) ---
    if (Array.isArray(input)) {
      return input
        .filter(item => item && typeof item === "object")
        .map(item => ({
          title: item.title || "",
          company: item.company || "",
          dates: item.dates || "",
          // Split on any newline variant, trim each line, remove blank-only lines
          description: (item.description || "")
            .split(/\r?\n/)
            .map(l => l.trim())
            .filter(l => l.length > 0)
            .join("\n")
        }));
    }

    // --- String format (legacy) ---
    if (!input || typeof input !== "string") return [];

    const lines = input
      .split(/\r?\n+/)
      .map(l => l.trim())
      .filter(l => l.length > 0);

    const jobs = [];
    let currentHeading = null;
    let currentDesc = [];

    for (const line of lines) {
      if (/^-/.test(line)) {
        if (currentHeading) {
          jobs.push({ heading: currentHeading, description: currentDesc.join(" ") });
        }
        currentHeading = line.replace(/^-\s*/, "");
        currentDesc = [];
      } else {
        currentDesc.push(line);
      }
    }

    if (currentHeading) {
      jobs.push({ heading: currentHeading, description: currentDesc.join(" ") });
    }

    return jobs.map(job => {
      // "Title [Company] (dates)" OR "Title (dates)"
      const mFull = job.heading.match(/^(.*?)\s*\[([^\]]+)\]\s*(\(.*\))\s*$/);
      const mDates = job.heading.match(/^(.*?)(\(\s*\d{4}.*\))\s*$/);
      if (mFull) {
        return { title: mFull[1].trim(), company: mFull[2].trim(), dates: mFull[3].trim(), description: job.description };
      }
      if (mDates) {
        return { title: mDates[1].trim(), company: "", dates: mDates[2].trim(), description: job.description };
      }
      return { title: job.heading, company: "", dates: "", description: job.description };
    });
  }

  // Simple bullets for skills: 1 line = 1 pill
  function renderBullets(text) {
    if (!text || typeof text !== "string") return [];
    return text
      .split(/\r?\n+/)
      .map(line => line.replace(/^\s*[-*•]\s*/, ""))
      .map(line => line.trim())
      .filter(line => line.length > 0);
  }

  let _expInput = data.experience || "";
  if (data.experienceJson) {
    try { _expInput = JSON.parse(data.experienceJson); } catch (_) {}
  }
  const experienceItems = parseExperience(_expInput);
  const skillsLines = renderBullets(data.skills || "");
%>

<style>
  /* ==== Preview / A4 wrapper ==== */
  .preview-section {
    padding: 1.5rem 1rem 2.5rem;
  }

  .preview-section > h1 {
    margin-bottom: 0.25rem;
  }

  .preview-section > p {
    margin-top: 0.2rem;
    margin-bottom: 0.75rem;
  }

  /* Scope UI styles to preview-section ONLY — not into the resume */
  .preview-section > button,
  .preview-section > .btn-primary,
  #download-image-btn,
  #download-pdf-btn {
    background: #111827;
    color: #fff;
    border: none;
    padding: 0.6rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
  }

  .preview-section > button:hover,
  .preview-section > .btn-primary:hover,
  #download-image-btn:hover,
  #download-pdf-btn:hover {
    background: #facc15;
    color: #111827;
  }

  /* Row wrapper for the two download buttons */
  .download-btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    margin-top: 1rem;
  }

  .preview-section > p > a,
  .preview-section > p a {
    color: #2563eb;
  }

  /* ===== OUTER WRAPPER: clips horizontal overflow, sized by JS ===== */
  .preview-wrapper {
    width: 100%;
    max-width: 820px;
    margin: 1rem auto;
    /*
     * overflow-x: clip  — prevents the 794px scale-container from creating a
     *   horizontal scrollbar on narrow screens. Unlike overflow:hidden, `clip`
     *   does NOT create a scroll container, so overflow-y can remain visible.
     * overflow-y: visible — content taller than the JS-set height can flow
     *   naturally; the page itself scrolls, not the wrapper.
     */
    overflow-x: clip;
    overflow-y: visible;
    position: relative;        /* stacking context for z-index */
  }

  /* ===== SCALE CONTAINER: holds the A4 and gets transform applied ===== */
  .preview-scale-container {
    width: 794px;              /* always A4 width */
    transform-origin: top left; /* set in CSS so JS never races to set it.
                                   Desktop: translateX centers it (origin irrelevant for translate).
                                   Mobile:  scale() anchors top-left — no rightward shift. */
  }

  /* ===== A4 CARD: captured as JPG, natural height for multi-page content ===== */
  .resume-a4 {
    width: 794px;
    min-height: 1123px;        /* A4 page height — content grows beyond this */
    height: auto;              /* MUST be auto so tall resumes expand naturally */
    background: #ffffff;
    box-shadow: 0 18px 40px rgba(15,23,42,0.18);
    border-radius: 8px;
    border: 1px solid #e5e7eb;
    overflow: hidden;          /* clip sidebar bg colours to border-radius */
    position: relative;
    box-sizing: border-box;
  }

  /*
   * ===== .preview-wrapper .resume-page — minimal safety guard =====
   * The real neutralisation of style.css legacy rules (display:flex,
   * overflow:hidden, background:#f3f4f6, margin, max-width, box-shadow,
   * border-radius) is now done in templates.css base .resume-page {} at 0,1,0
   * via cascade order (templates.css loads after style.css).
   *
   * Template-specific display/background rules at 0,2,0 in templates.css
   * are NOT overridden here, so two-column templates (modern-1, bold-sidebar)
   * get their display:flex back and tech-focused gets its dark background back.
   *
   * This rule (0,2,0) only guards the three properties most critical to
   * the preview layout being correct.
   */
  .preview-wrapper .resume-page {
    margin: 0 !important;         /* style.css: margin:1.5rem auto — must never apply here */
    max-width: none !important;   /* style.css: max-width:900px — A4 is fixed at 794px */
    overflow: visible !important; /* must never clip multi-page vertical content */
  }

  /* ===== PRINT ===== */
  @media print {
    @page {
      size: A4;
      margin: 0;
    }

    body {
      margin: 0;
      background: #ffffff;
    }

    .preview-section > h1,
    .preview-section > p,
    #download-image-btn,
    #print-btn {
      display: none !important;
    }

    .preview-wrapper {
      overflow: visible;
      max-width: none;
      height: auto !important;   /* override JS-set pixel height */
    }

    .preview-scale-container {
      transform: none !important;  /* remove translateX / scale for print */
      margin: 0 auto;
    }

    .resume-a4 {
      width: 210mm;
      border: none;
      box-shadow: none;
      border-radius: 0;
      overflow: visible;         /* let content flow across print pages */
      min-height: auto;
      height: auto;
      margin: 0 auto;
    }

    /* ── Keep A4 page structure intact ── */
    .resume-page {
      overflow: visible !important;
      height: auto !important;
      min-height: auto !important;
    }

    /* ── Prevent experience entries from splitting across print pages ── */
    .experience-list li,
    .es-exp-item,
    .tf-exp-item,
    .cb-exp-item {
      page-break-inside: avoid;
      break-inside: avoid;
    }

    /* ── Keep section headings with their first line of content ── */
    .modern-section-block h3,
    .bs-content-section h3,
    .min-section h3,
    .cg-section h3,
    .corp-section h3,
    .es-section h3,
    .tf-section h3,
    .cb-section h3 {
      page-break-after: avoid;
      break-after: avoid;
    }

    /* ── Avoid splitting whole short sections ── */
    .modern-section-block,
    .bs-content-section,
    .min-section,
    .cg-section,
    .corp-section,
    .es-section,
    .tf-section,
    .cb-section {
      page-break-inside: avoid;
      break-inside: avoid;
    }
  }

  .resume-watermark {
    position: absolute;
    inset: 0;
    z-index: 999;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 3.2rem;
    font-weight: 700;
    color: rgba(17, 24, 39, 0.08);
    letter-spacing: 0.25em;
    text-transform: uppercase;
    transform: rotate(-30deg);
    user-select: none;
  }

  /* ===== MULTI-PAGE: visual page-break dividers ===== */
  .pg-break {
    position: absolute;
    left: 0;
    right: 0;
    pointer-events: none;
    z-index: 60;
    /* 16px band: top 8px = shadow of page above, bottom 8px = shadow of page below */
    height: 16px;
    background:
      linear-gradient(to bottom, rgba(0,0,0,0.12) 0%, transparent 100%);
  }

  .pg-break::before {
    content: "";
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 3px;
    background: #b0b8c9;
  }

  /* Stack multiple page cards with a visible gap */
  .preview-scale-container {
    display: flex;
    flex-direction: column;
    gap: 0;          /* pages are continuous — breaks shown as overlays */
  }
</style>

<section class="preview-section">
  <h1>Resume Preview</h1>
  <p>
    Review your resume below. Download as JPG or PDF after payment.
    <br />
    Template: <strong><%= tpl %></strong>
    &nbsp;&middot;&nbsp; <a href="/resume-templates">Change template</a>
  </p>

  <!-- OUTER: clips overflow, prevents horizontal scroll -->
  <div class="preview-wrapper">
    <!-- SCALE CONTAINER: JS applies transform: scale() here on mobile -->
    <div class="preview-scale-container" id="scaleContainer">
      <!-- A4 container we capture for JPG / print -->
      <div id="resumeA4" class="resume-a4">
        <!-- WATERMARK (VISIBLE UNTIL PAYMENT) -->
        <div class="resume-watermark">
          SmrAI-Studio &bull; Preview &bull; Not Paid
        </div>

        <div class="resume-page <%= safeTpl %>">
          <%- include('templates/' + safeTpl, { data, experienceItems, skillsLines }) %>
        </div>
      </div>
    </div>
  </div>

  <!-- Download buttons — both unlock after a single payment -->
  <div class="download-btn-row">
    <button id="download-image-btn">PAY ₹49 &amp; DOWNLOAD JPG (A4)</button>
    <button id="download-pdf-btn">PAY ₹49 &amp; DOWNLOAD PDF (A4)</button>
  </div>

  <p style="margin-top:1rem;">
    <a href="/resume-builder">Edit details</a>
  </p>
</section>

<!-- ===== DYNAMIC MOBILE SCALING + MULTI-PAGE BREAKS ===== -->
<script>
  (function () {
    var A4_WIDTH  = 794;
    var A4_HEIGHT = 1123;   /* px at screen resolution */

    /* Inject/refresh visual page-break dividers */
    function refreshPageBreaks() {
      var a4 = document.getElementById("resumeA4");
      if (!a4) return;

      /* Remove stale indicators */
      var old = a4.querySelectorAll(".pg-break");
      for (var i = 0; i < old.length; i++) old[i].parentNode.removeChild(old[i]);

      var totalH = a4.offsetHeight;
      var pages  = Math.ceil(totalH / A4_HEIGHT);
      if (pages <= 1) return;

      for (var p = 1; p < pages; p++) {
        var div = document.createElement("div");
        div.className = "pg-break";
        div.style.top = (p * A4_HEIGHT - 8) + "px";  /* straddle the boundary */
        a4.appendChild(div);
      }
    }

    function scalePreview() {
      var wrapper   = document.querySelector(".preview-wrapper");
      var container = document.getElementById("scaleContainer");
      var a4        = document.getElementById("resumeA4");
      if (!wrapper || !container || !a4) return;

      /*
       * getBoundingClientRect() reads the ACTUAL rendered width of the wrapper.
       * It is more reliable than clientWidth on mobile browsers where an
       * overflowing child can inflate the parent's reported clientWidth.
       * Clamp to window.innerWidth as a final safety net — the wrapper
       * can never legitimately be wider than the viewport.
       */
      var availableWidth = wrapper.getBoundingClientRect().width;
      if (availableWidth > window.innerWidth) {
        availableWidth = window.innerWidth;
      }
      if (availableWidth <= 0) return; /* layout not ready yet */

      /*
       * Measure the A4's natural (un-transformed) height.
       * If images haven't loaded yet this may be an underestimate — the
       * "load" event re-runs scalePreview() once all resources are ready.
       */
      var naturalHeight = a4.offsetHeight || 1123;

      if (availableWidth >= A4_WIDTH) {
        /*
         * DESKTOP — center the 794px container inside the wrapper via
         * translateX instead of margin:auto.  translateX is explicit and
         * cannot be confused by the browser's block-layout auto-margin
         * algorithm when the child is wider than the parent.
         * transform-origin is already "top left" (set in CSS), so the
         * translate is always relative to the element's own top-left corner.
         */
        var offset = Math.round((availableWidth - A4_WIDTH) / 2);
        container.style.transform      = "translateX(" + offset + "px)";
        container.style.transformOrigin = "top left";
        container.style.margin         = "0";
        wrapper.style.height           = naturalHeight + "px";
      } else {
        /*
         * MOBILE — scale the A4 down so its visual width exactly fills the
         * available wrapper width.  transform-origin "top left" anchors the
         * scale to the wrapper's top-left corner, so the left edge of the
         * resume stays flush with the left edge of the wrapper — no
         * rightward shift, no sidebar clipping.
         *
         * The wrapper's explicit height is set to the visually-scaled height
         * so no empty space appears below the preview.
         */
        var scale = availableWidth / A4_WIDTH;
        container.style.transform       = "scale(" + scale + ")";
        container.style.transformOrigin = "top left";
        container.style.margin          = "0";
        wrapper.style.height            = Math.ceil(naturalHeight * scale) + "px";
      }

      /* Show page-break dividers whenever content exceeds one A4 height */
      refreshPageBreaks();
    }

    /*
     * Defer the first run by one animation frame so the browser has
     * finished painting the initial layout (getBoundingClientRect will
     * return the true rendered width, not 0 or a stale value).
     */
    function init() {
      requestAnimationFrame(function () {
        scalePreview();
      });
      window.addEventListener("resize", scalePreview);
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", init);
    } else {
      init();
    }

    /* Re-run after all resources (images, fonts) finish loading — the
       A4 height may increase once profile photos are rendered. */
    window.addEventListener("load", function () {
      requestAnimationFrame(scalePreview);
    });
  })();
</script>

<!-- JSZip: used to package multi-page JPG exports into a single ZIP download -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://checkout.razorpay.com/v1/checkout.js"></script>

<!-- Resume data embedded safely for PDF form submission (type=application/json prevents execution) -->
<script id="resume-payload" type="application/json">
<%- JSON.stringify({
  resumeId:        data.resumeId        || "",
  fullName:        data.fullName        || "",
  email:           data.email           || "",
  phone:           data.phone           || "",
  summary:         data.summary         || "",
  experience:      data.experience      || "",
  experienceJson:  data.experienceJson  || "",
  education:       data.education       || "",
  skills:          data.skills          || "",
  profileImageUrl: data.profileImageUrl || ""
}) %>
</script>

<script>
  (function () {
    const resumeNode = document.getElementById("resumeA4");
    const downloadBtn = document.getElementById("download-image-btn");
    const pdfBtn      = document.getElementById("download-pdf-btn");
    if (!resumeNode || !downloadBtn || !pdfBtn) return;

    const resumeId    = "<%= data.resumeId || '' %>";
    const templateName = "<%= safeTpl %>";

    // Parse the safely-embedded resume data (used for PDF form submission)
    let resumePayload = {};
    try {
      const el = document.getElementById("resume-payload");
      if (el) resumePayload = JSON.parse(el.textContent);
    } catch (_) {}

    // Shared payment flag — only one Razorpay transaction needed for both exports
    let paymentVerified = false;

    // ================================================================
    // Image helpers — convert <img> src to data URLs before capture
    // so html2canvas can read pixel data regardless of CORS headers.
    // ================================================================
    async function preloadImagesAsDataUrls(container) {
      const imgs = Array.from(container.querySelectorAll("img"));
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        if (!img.src || img.src.startsWith("data:")) continue;

        // Wait for the image to finish loading if it hasn't yet
        if (!img.complete) {
          await new Promise(function (resolve) {
            img.addEventListener("load",  resolve, { once: true });
            img.addEventListener("error", resolve, { once: true });
          });
        }

        // Fetch the image and convert to a base-64 data URL
        try {
          var res  = await fetch(img.src, { credentials: "same-origin" });
          var blob = await res.blob();
          var dataUrl = await new Promise(function (resolve) {
            var reader = new FileReader();
            reader.onload = function () { resolve(reader.result); };
            reader.readAsDataURL(blob);
          });
          img.setAttribute("data-orig-src", img.src);
          img.src = dataUrl;
        } catch (e) {
          console.warn("Could not preload image as data URL:", img.src, e);
        }
      }
    }

    function restoreImageSrcs(container) {
      container.querySelectorAll("img[data-orig-src]").forEach(function (img) {
        img.src = img.getAttribute("data-orig-src");
        img.removeAttribute("data-orig-src");
      });
    }

    // ================================================================
    // JPG generation — single page = direct download, multi-page = ZIP
    // ================================================================
    async function generateJpg() {
      downloadBtn.disabled = true;
      pdfBtn.disabled      = true;
      const origText = downloadBtn.textContent;
      downloadBtn.textContent = "Preparing JPG…";

      try {
        const A4_WIDTH_PX  = 2480;
        const A4_HEIGHT_PX = 3508;

        // Remove CSS transform so html2canvas sees the full unscaled element
        const scaleContainer = document.getElementById("scaleContainer");
        const prevTransform  = scaleContainer ? scaleContainer.style.transform : "";
        const wrapperEl      = document.querySelector(".preview-wrapper");
        const prevWrapperH   = wrapperEl ? wrapperEl.style.height : "";
        if (scaleContainer) scaleContainer.style.transform = "none";
        if (wrapperEl) wrapperEl.style.height = "auto";

        // Hide page-break overlays — must not appear in the exported images
        const pgBreaks = resumeNode.querySelectorAll(".pg-break");
        pgBreaks.forEach(function (el) { el.style.display = "none"; });

        // Convert all <img> src values to data URLs so html2canvas can
        // render them without hitting browser CORS/canvas-taint restrictions
        await preloadImagesAsDataUrls(resumeNode);

        const baseWidth = resumeNode.offsetWidth;
        const scale     = A4_WIDTH_PX / baseWidth;

        const fullCanvas = await html2canvas(resumeNode, {
          scale:           scale,
          backgroundColor: "#ffffff",
          useCORS:         true,   /* fallback for any img not converted above */
          allowTaint:      false,
          scrollX:         0,
          scrollY:         -window.scrollY,
          windowWidth:     resumeNode.scrollWidth,
          windowHeight:    resumeNode.scrollHeight,
        });

        // Restore transforms, overlays, and original image src attributes
        if (scaleContainer) scaleContainer.style.transform = prevTransform;
        if (wrapperEl) wrapperEl.style.height = prevWrapperH;
        pgBreaks.forEach(function (el) { el.style.display = ""; });
        restoreImageSrcs(resumeNode);

        const fullHeight = fullCanvas.height;
        const totalPages = Math.ceil(fullHeight / A4_HEIGHT_PX);

        // Slice canvas at page index i → JPEG Blob
        function sliceToBlob(i) {
          return new Promise(function (resolve) {
            const pc    = document.createElement("canvas");
            const sliceH = Math.min(A4_HEIGHT_PX, fullHeight - i * A4_HEIGHT_PX);
            pc.width  = A4_WIDTH_PX;
            pc.height = sliceH;
            const ctx = pc.getContext("2d");
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, A4_WIDTH_PX, sliceH);
            ctx.drawImage(fullCanvas,
              0, i * A4_HEIGHT_PX, A4_WIDTH_PX, sliceH,
              0, 0,                A4_WIDTH_PX, sliceH);
            pc.toBlob(resolve, "image/jpeg", 0.95);
          });
        }

        if (totalPages === 1) {
          // ── Single page: direct JPEG download ──────────────────────
          const blob = await sliceToBlob(0);
          const url  = URL.createObjectURL(blob);
          const a    = document.createElement("a");
          a.download = "SmrAI-Studio-Resume.jpg";
          a.href     = url;
          a.click();
          setTimeout(function () { URL.revokeObjectURL(url); }, 5000);

        } else {
          // ── Multiple pages: ZIP all pages then download ─────────────
          if (typeof JSZip === "undefined") {
            throw new Error("JSZip not loaded — cannot create ZIP file.");
          }
          downloadBtn.textContent = "Packaging " + totalPages + " pages…";
          const zip = new JSZip();
          for (var i = 0; i < totalPages; i++) {
            const blob = await sliceToBlob(i);
            zip.file("resume-page-" + (i + 1) + ".jpg", blob);
          }
          downloadBtn.textContent = "Building ZIP…";
          const zipBlob = await zip.generateAsync({
            type: "blob",
            compression: "DEFLATE",
            compressionOptions: { level: 6 },
          });
          const url = URL.createObjectURL(zipBlob);
          const a   = document.createElement("a");
          a.download = "SmrAI-Studio-Resume-Pages.zip";
          a.href     = url;
          a.click();
          setTimeout(function () { URL.revokeObjectURL(url); }, 10000);
        }

      } catch (err) {
        console.error("JPG export error:", err);
        alert("Failed to generate image. Check console for details.");
      } finally {
        downloadBtn.disabled    = false;
        pdfBtn.disabled         = false;
        downloadBtn.textContent = paymentVerified ? "Download JPG (A4)" : origText;
      }
    }

    // ================================================================
    // PDF generation — html2canvas captures the live DOM (same as JPG),
    // then jsPDF assembles pages into a downloadable PDF.
    // Layout is identical to the preview — no server-side rebuild needed.
    // ================================================================
    async function generatePdf() {
      pdfBtn.disabled      = true;
      downloadBtn.disabled = true;
      const origText = pdfBtn.textContent;
      pdfBtn.textContent = "Preparing PDF…";

      try {
        const A4_WIDTH_PX  = 2480;
        const A4_HEIGHT_PX = 3508;

        // Remove CSS transform so html2canvas sees the full unscaled element
        const scaleContainer = document.getElementById("scaleContainer");
        const prevTransform  = scaleContainer ? scaleContainer.style.transform : "";
        const wrapperEl      = document.querySelector(".preview-wrapper");
        const prevWrapperH   = wrapperEl ? wrapperEl.style.height : "";
        if (scaleContainer) scaleContainer.style.transform = "none";
        if (wrapperEl) wrapperEl.style.height = "auto";

        // Hide page-break overlays — must not appear in the exported PDF
        const pgBreaks = resumeNode.querySelectorAll(".pg-break");
        pgBreaks.forEach(function (el) { el.style.display = "none"; });

        // Convert all <img> src values to data URLs so html2canvas can
        // render them without hitting browser CORS/canvas-taint restrictions
        await preloadImagesAsDataUrls(resumeNode);

        const baseWidth = resumeNode.offsetWidth;
        const scale     = A4_WIDTH_PX / baseWidth;

        const fullCanvas = await html2canvas(resumeNode, {
          scale:           scale,
          backgroundColor: "#ffffff",
          useCORS:         true,
          allowTaint:      false,
          scrollX:         0,
          scrollY:         -window.scrollY,
          windowWidth:     resumeNode.scrollWidth,
          windowHeight:    resumeNode.scrollHeight,
        });

        // Restore transforms, overlays, and original image src attributes
        if (scaleContainer) scaleContainer.style.transform = prevTransform;
        if (wrapperEl) wrapperEl.style.height = prevWrapperH;
        pgBreaks.forEach(function (el) { el.style.display = ""; });
        restoreImageSrcs(resumeNode);

        const fullHeight = fullCanvas.height;
        const totalPages = Math.ceil(fullHeight / A4_HEIGHT_PX);

        // PDF page size in px — matches A4 at screen resolution
        const PDF_W = 794;
        const PDF_H = 1123;

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: "portrait",
          unit:        "px",
          format:      [PDF_W, PDF_H],
          compress:    true,
        });

        pdfBtn.textContent = totalPages > 1
          ? "Building " + totalPages + " pages…"
          : "Building PDF…";

        for (var i = 0; i < totalPages; i++) {
          if (i > 0) pdf.addPage([PDF_W, PDF_H], "portrait");

          const sliceH = Math.min(A4_HEIGHT_PX, fullHeight - i * A4_HEIGHT_PX);

          // Slice this page from the full high-res canvas
          const pc  = document.createElement("canvas");
          pc.width  = A4_WIDTH_PX;
          pc.height = sliceH;
          const ctx = pc.getContext("2d");
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, A4_WIDTH_PX, sliceH);
          ctx.drawImage(
            fullCanvas,
            0, i * A4_HEIGHT_PX, A4_WIDTH_PX, sliceH,
            0, 0,                A4_WIDTH_PX, sliceH
          );

          const imgData  = pc.toDataURL("image/jpeg", 0.95);
          const pageImgH = (sliceH / A4_HEIGHT_PX) * PDF_H;  // proportional height for last page
          pdf.addImage(imgData, "JPEG", 0, 0, PDF_W, pageImgH);
        }

        pdf.save("SmrAI-Studio-Resume.pdf");

      } catch (err) {
        console.error("PDF export error:", err);
        alert("Failed to generate PDF. Check console for details.");
      } finally {
        pdfBtn.disabled      = false;
        downloadBtn.disabled = false;
        pdfBtn.textContent   = paymentVerified ? "Download PDF (A4)" : origText;
      }
    }

    // ================================================================
    // Razorpay payment — shared between JPG and PDF actions
    // Only ONE transaction is triggered; both buttons unlock after it
    // ================================================================
    async function createOrder() {
      const res  = await fetch("/api/razorpay/create-order", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
      });
      const json = await res.json();
      if (!json.success) throw new Error("Order creation failed");
      return json;
    }

    async function startPayment(action) {
      try {
        const orderData = await createOrder();

        const options = {
          key:         orderData.key,
          amount:      orderData.amount,
          currency:    orderData.currency,
          name:        "SmrAI-Studio",
          description: templateName + " Resume Download",
          order_id:    orderData.orderId,

          handler: async function (response) {
            try {
              const verifyRes = await fetch("/api/razorpay/verify", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  razorpay_order_id:   response.razorpay_order_id,
                  razorpay_payment_id: response.razorpay_payment_id,
                  razorpay_signature:  response.razorpay_signature,
                  purpose:             "download",
                  resumeId:            resumeId || null,
                }),
              });

              const verifyData = await verifyRes.json();
              if (!verifyData.success) {
                alert("Payment verification failed. Please contact support.");
                return;
              }

              // Mark payment done — shared state, no second charge needed
              paymentVerified = true;

              // Remove watermark
              const wm = document.querySelector(".resume-watermark");
              if (wm) wm.remove();

              // Unlock both button labels
              downloadBtn.textContent = "Download JPG (A4)";
              pdfBtn.textContent      = "Download PDF (A4)";

              // Run the action that originally triggered the payment
              if (action === "jpg") {
                await generateJpg();
              } else if (action === "pdf") {
                await generatePdf();
              }

            } catch (err) {
              console.error("Verify/payment error:", err);
              alert("Something went wrong while verifying payment.");
            }
          },

          prefill: {
            name:    resumePayload.fullName || "",
            email:   resumePayload.email    || "",
            contact: resumePayload.phone    || "",
          },
          theme: { color: "#27355a" },
        };

        new Razorpay(options).open();

      } catch (err) {
        console.error(err);
        alert("Unable to start payment. Please try again.");
      }
    }

    // ================================================================
    // Button click handlers
    // ================================================================
    downloadBtn.addEventListener("click", function () {
      if (paymentVerified) { generateJpg(); } else { startPayment("jpg"); }
    });

    pdfBtn.addEventListener("click", function () {
      if (paymentVerified) { generatePdf(); } else { startPayment("pdf"); }
    });

  })();
</script>

<%- include("partials/footer") %>
